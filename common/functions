1p() {
    # First, run the 1p setup
    echo "Setting up 1Password CLI..."
    
    # Better check if actually installed and executable
    if ! which op >/dev/null 2>&1; then
        echo "Installing 1Password CLI..."

        {
            # Use proper temp files with correct permissions
            TEMP_DIR=$(mktemp -d)
            trap 'rm -rf "$TEMP_DIR"' EXIT

            # Download and check if we need to update the keyring
            curl -sS https://downloads.1password.com/linux/keys/1password.asc -o "$TEMP_DIR/1password.asc"

            if [ -f /usr/share/keyrings/1password-archive-keyring.gpg ]; then
                # Compare existing with new
                gpg --dearmor -o "$TEMP_DIR/1password-archive-keyring.gpg" < "$TEMP_DIR/1password.asc" 2>/dev/null
                if cmp -s /usr/share/keyrings/1password-archive-keyring.gpg "$TEMP_DIR/1password-archive-keyring.gpg"; then
                    echo "Keyring is up-to-date."
                else
                    echo "Updating keyring..."
                    sudo cp "$TEMP_DIR/1password-archive-keyring.gpg" /usr/share/keyrings/1password-archive-keyring.gpg
                fi
            else
                # First time installation
                gpg --dearmor < "$TEMP_DIR/1password.asc" | sudo tee /usr/share/keyrings/1password-archive-keyring.gpg >/dev/null
            fi

            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/1password-archive-keyring.gpg] https://downloads.1password.com/linux/debian/$(dpkg --print-architecture) stable main" | \
            sudo tee /etc/apt/sources.list.d/1password.list > /dev/null

            sudo mkdir -p /etc/debsig/policies/AC2D62742012EA22/
            curl -sS https://downloads.1password.com/linux/debian/debsig/1password.pol -o "$TEMP_DIR/1password.pol"
            if [ ! -f /etc/debsig/policies/AC2D62742012EA22/1password.pol ] || ! cmp -s "$TEMP_DIR/1password.pol" /etc/debsig/policies/AC2D62742012EA22/1password.pol; then
                sudo cp "$TEMP_DIR/1password.pol" /etc/debsig/policies/AC2D62742012EA22/1password.pol
            fi

            sudo mkdir -p /usr/share/debsig/keyrings/AC2D62742012EA22
            curl -sS https://downloads.1password.com/linux/keys/1password.asc -o "$TEMP_DIR/1password-debsig.asc"
            if [ -f /usr/share/debsig/keyrings/AC2D62742012EA22/debsig.gpg ]; then
                gpg --dearmor -o "$TEMP_DIR/debsig.gpg" < "$TEMP_DIR/1password-debsig.asc" 2>/dev/null
                if ! cmp -s /usr/share/debsig/keyrings/AC2D62742012EA22/debsig.gpg "$TEMP_DIR/debsig.gpg"; then
                    sudo cp "$TEMP_DIR/debsig.gpg" /usr/share/debsig/keyrings/AC2D62742012EA22/debsig.gpg
                fi
            else
                gpg --dearmor < "$TEMP_DIR/1password-debsig.asc" | sudo tee /usr/share/debsig/keyrings/AC2D62742012EA22/debsig.gpg >/dev/null
            fi

            sudo apt update && sudo apt install -y 1password-cli
        } || {
            echo "Installation failed. Check network connection or permissions."
            return 1
        }
    fi

    # Double check installation worked
    if ! which op >/dev/null 2>&1; then
        echo "Error: 1Password CLI installation failed."
        return 1
    fi

    # Check if we already have a token stored
    local token_loaded_from_file=false
    if [ -f /etc/secrets/.1p ]; then
        source /etc/secrets/.1p
        if [ -n "$OP_SERVICE_ACCOUNT_TOKEN" ]; then
            echo "Using stored 1Password service account token."
            # Test if stored token still works
            if op vault list >/dev/null 2>&1; then
                echo -e "\nSuccessfully authenticated!"
                token_loaded_from_file=true
            else
                echo "Stored token is invalid. Please enter a new one."
            fi
        fi
    fi

    # If token not loaded from file, decrypt it from network share
    if [ "$token_loaded_from_file" = false ]; then
        # Secure credential input
        echo -e "\nDecrypting 1Password token:"
        
        # Get password from user to decrypt token
        while true; do
            read -rsp "Enter password to decrypt token: " decrypt_password
            echo  # New line after password input
            [[ -n "$decrypt_password" ]] && break
            echo -e "\nError: Password cannot be empty"
        done
        
        # Create temp directory for mounting SMB share
        TEMP_MOUNT=$(mktemp -d)
        trap 'rmdir "$TEMP_MOUNT" 2>/dev/null || true' EXIT
        
        echo "Fetching encrypted token from syno.home.arpa..."
        # Mount SMB share temporarily
        mount -t cifs //syno.home.arpa/deployment "$TEMP_MOUNT" -o guest,ro 2>/dev/null
        
        if [ $? -eq 0 ]; then
            if [ -f "$TEMP_MOUNT/encrypted-1p-token" ]; then
                # Decrypt the token file with the provided password
                token=$(openssl enc -aes-256-cbc -d -salt -in "$TEMP_MOUNT/encrypted-1p-token" -pass pass:"$decrypt_password" 2>/dev/null)
                
                # Check if decryption was successful
                if [ $? -ne 0 ]; then
                    echo "Error: Failed to decrypt token. Incorrect password."
                    umount "$TEMP_MOUNT" 2>/dev/null
                    rmdir "$TEMP_MOUNT" 2>/dev/null
                    return 1
                fi
            else
                echo "Error: Encrypted token file not found at syno.home.arpa/deployment"
                umount "$TEMP_MOUNT" 2>/dev/null
                rmdir "$TEMP_MOUNT" 2>/dev/null
                return 1
            fi
            # Unmount SMB share
            umount "$TEMP_MOUNT" 2>/dev/null
            rmdir "$TEMP_MOUNT" 2>/dev/null
        else
            echo "Error: Could not connect to syno.home.arpa/deployment"
            rmdir "$TEMP_MOUNT" 2>/dev/null
            return 1
        fi
        
        echo "Token successfully decrypted."
        
        # Set the service account token
        export OP_SERVICE_ACCOUNT_TOKEN="$token"

        # Test authentication by listing vaults
        if ! op vault list >/dev/null 2>&1; then
            echo -e "\nAuthentication failed. Verify token validity."
            unset OP_SERVICE_ACCOUNT_TOKEN
            return 1
        fi

        echo -e "\nSuccessfully authenticated!"
    fi

    # Now proceed with the secrets management part
    echo -e "\nConfiguring secrets management..."

    # Check if running as root
    if [ "$(id -u)" -eq 0 ]; then
        echo "Error: This function should be run as a regular user, not root."
        return 1
    fi

    # Get the current username
    local current_user=$(whoami)

    # Create the secrets group if it doesn't exist
    if ! getent group secrets > /dev/null; then
        echo "Creating secrets group..."
        sudo groupadd secrets
    else
        echo "Secrets group already exists."
    fi

    # Check if user is already in the secrets group
    if id -nG "$current_user" | grep -qw "secrets"; then
        echo "$current_user is already a member of the secrets group."
    else
        echo "Adding $current_user to secrets group..."
        sudo usermod -a -G secrets "$current_user"
    fi

    # Ensure /etc/secrets exists with secure permissions
    sudo mkdir -p /etc/secrets
    sudo chown root:secrets /etc/secrets
    sudo chmod 750 /etc/secrets  # Allow directory traversal for secrets group

    # Save token if not already saved
    if [ "$token_loaded_from_file" = false ]; then
        echo -e "\nSaving token to /etc/secrets/.1p..."
        echo "export OP_SERVICE_ACCOUNT_TOKEN='$token'" | sudo tee /etc/secrets/.1p >/dev/null
        sudo chown root:secrets /etc/secrets/.1p
        sudo chmod 640 /etc/secrets/.1p
    fi

    # Fix ownership and permissions for any existing files (including hidden files)
    if [ -d /etc/secrets ] && [ "$(sudo find /etc/secrets -mindepth 1 | wc -l)" -gt 0 ]; then
        echo "Fixing ownership and permissions for existing files..."
        sudo find /etc/secrets -mindepth 1 -maxdepth 1 -exec chown root:secrets {} \;
        sudo find /etc/secrets -mindepth 1 -maxdepth 1 -exec chmod 640 {} \;
    fi

    # Get Debian vault items with explicit --vault flag
    echo -e "\nExporting vault items..."
    items=$(op item list --vault "Debian" --format json | jq -r '.[].id')

    # Export each item to /etc/secrets
    for id in $items; do
        # Get item details with explicit --vault flag
        item_json=$(op item get "$id" --vault "Debian" --format json)
        
        # Extract title and content
        title=$(jq -r '.title' <<< "$item_json")
        content=$(jq -r '.fields[]?.value // .notes' <<< "$item_json")
        
        # Write to temporary file first for atomic replacement
        temp_file=$(mktemp)
        echo "$content" > "$temp_file"
        
        # Move with proper ownership and permissions
        sudo mv "$temp_file" "/etc/secrets/${title}"
        sudo chown root:secrets "/etc/secrets/${title}"
        sudo chmod 640 "/etc/secrets/${title}"
    done

    echo "Vault items exported successfully."
    
    # Only remind about login if user was just added to the group
    if ! id -nG "$current_user" | grep -qw "secrets"; then
        echo "Note: You may need to log out and back in for group membership to take effect."
        echo "Or run: newgrp secrets"
    fi

    # Ask about keeping token in current shell only if we loaded it fresh
    if [ "$token_loaded_from_file" = false ]; then
        read -rp "Keep OP_SERVICE_ACCOUNT_TOKEN in current shell? [y/N] " keep
        [[ "$keep" != [yY]* ]] && unset OP_SERVICE_ACCOUNT_TOKEN
    fi
}

goto() {
    local file_path=$(fzf --select-1 --exit-0)

    if [ -z "$file_path" ]; then
        echo "No file selected."
        return 1
    fi

    local dir_path=$(dirname "$file_path")

    cd "$dir_path" || return
}

n() {
    if [ -z "$1" ]; then
        nano $(fzf)
    else
        (cd "$1" && nano $(fzf))
    fi
}

port() {
    echo "Checking open files with port $1..."
    echo ""
    sudo lsof -i TCP:$1 -i UDP:$1 | awk 'NR==1 {print} /TCP.*LISTEN|UDP/'
    echo ""

    echo "Searching in /etc/nginx/sites-available/ for port $1..."
    echo ""
    grep -rnH "$1" /etc/nginx/sites-available/ | cut -d: -f1-3
    echo ""

    echo "Checking Docker containers for port $1..."
    echo ""
    docker ps --format "table {{.ID}}\t{{.Image}}\t{{.Ports}}" | grep "$1"
    echo ""
}

pw() {
  default_length=40

  if [[ $1 == "n" ]]; then
    read -p "Enter desired password length: " characters
  else
    read -p "Generating new string... Press Enter for 40 characters / Press n to specify number of characters: " confirm
    if [[ $confirm == "n" ]]; then
      read -p "Enter desired string length: " characters
    else
      characters=$default_length
    fi
  fi

  openssl rand -base64 $characters
}
