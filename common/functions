1p() {
    # First, run the 1p setup
    echo "Setting up 1Password CLI..."

    # Better check if actually installed and executable
    if ! which op >/dev/null 2>&1; then
        echo "Installing 1Password CLI..."

        {
            # Use proper temp files with correct permissions
            TEMP_DIR=$(mktemp -d)
            trap 'rm -rf "$TEMP_DIR"' EXIT

            # Download and check if we need to update the keyring
            curl -sS https://downloads.1password.com/linux/keys/1password.asc -o "$TEMP_DIR/1password.asc"

            if [ -f /usr/share/keyrings/1password-archive-keyring.gpg ]; then
                # Compare existing with new
                gpg --dearmor -o "$TEMP_DIR/1password-archive-keyring.gpg" < "$TEMP_DIR/1password.asc" 2>/dev/null
                if cmp -s /usr/share/keyrings/1password-archive-keyring.gpg "$TEMP_DIR/1password-archive-keyring.gpg"; then
                    echo "Keyring is up-to-date."
                else
                    echo "Updating keyring..."
                    sudo cp "$TEMP_DIR/1password-archive-keyring.gpg" /usr/share/keyrings/1password-archive-keyring.gpg
                fi
            else
                # First time installation
                gpg --dearmor < "$TEMP_DIR/1password.asc" | sudo tee /usr/share/keyrings/1password-archive-keyring.gpg >/dev/null
            fi

            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/1password-archive-keyring.gpg] https://downloads.1password.com/linux/debian/$(dpkg --print-architecture) stable main" | \
            sudo tee /etc/apt/sources.list.d/1password.list > /dev/null

            sudo mkdir -p /etc/debsig/policies/AC2D62742012EA22/
            curl -sS https://downloads.1password.com/linux/debian/debsig/1password.pol -o "$TEMP_DIR/1password.pol"
            if [ ! -f /etc/debsig/policies/AC2D62742012EA22/1password.pol ] || ! cmp -s "$TEMP_DIR/1password.pol" /etc/debsig/policies/AC2D62742012EA22/1password.pol; then
                sudo cp "$TEMP_DIR/1password.pol" /etc/debsig/policies/AC2D62742012EA22/1password.pol
            fi

            sudo mkdir -p /usr/share/debsig/keyrings/AC2D62742012EA22
            curl -sS https://downloads.1password.com/linux/keys/1password.asc -o "$TEMP_DIR/1password-debsig.asc"
            if [ -f /usr/share/debsig/keyrings/AC2D62742012EA22/debsig.gpg ]; then
                gpg --dearmor -o "$TEMP_DIR/debsig.gpg" < "$TEMP_DIR/1password-debsig.asc" 2>/dev/null
                if ! cmp -s /usr/share/debsig/keyrings/AC2D62742012EA22/debsig.gpg "$TEMP_DIR/debsig.gpg"; then
                    sudo cp "$TEMP_DIR/debsig.gpg" /usr/share/debsig/keyrings/AC2D62742012EA22/debsig.gpg
                fi
            else
                gpg --dearmor < "$TEMP_DIR/1password-debsig.asc" | sudo tee /usr/share/debsig/keyrings/AC2D62742012EA22/debsig.gpg >/dev/null
            fi

            sudo apt update && sudo apt install -y 1password-cli
        } || {
            echo "Installation failed. Check network connection or permissions."
            return 1
        }
    fi

    # Double check installation worked
    if ! which op >/dev/null 2>&1; then
        echo "Error: 1Password CLI installation failed."
        return 1
    fi

    # Check if we already have a token stored
    local token_loaded_from_file=false
    if [ -f /etc/secrets/.1p ]; then
        source /etc/secrets/.1p
        if [ -n "$OP_SERVICE_ACCOUNT_TOKEN" ]; then
            echo "Using stored 1Password service account token."
            # Test if stored token still works
            if op vault list >/dev/null 2>&1; then
                echo -e "\nSuccessfully authenticated!"
                token_loaded_from_file=true
            else
                echo "Stored token is invalid. Please enter a new one."
            fi
        fi
    fi

    # If token not loaded from file, decrypt it from network share
    if [ "$token_loaded_from_file" = false ]; then
        # Secure credential input
        echo -e "\nDecrypting 1Password token:"

        # Get password from user to decrypt token
        while true; do
            read -rsp "Enter password to decrypt token: " decrypt_password
            echo  # New line after password input
            [[ -n "$decrypt_password" ]] && break
            echo -e "\nError: Password cannot be empty"
        done

        echo "Fetching encrypted token from syno.home.arpa..."

        # Check if smbclient is installed
        if ! which smbclient >/dev/null 2>&1; then
            echo "Installing smbclient..."
            sudo apt-get update && sudo apt-get install -y smbclient

            if ! which smbclient >/dev/null 2>&1; then
                echo "Error: Failed to install smbclient. Cannot fetch token."
                return 1
            fi
        fi

        # Create a temporary directory for the token
        TOKEN_DIR=$(mktemp -d)
        trap 'rm -rf "$TOKEN_DIR" 2>/dev/null || true' EXIT

        # Use smbclient to fetch the encrypted token
        if smbclient //syno.home.arpa/deployment -U 'guest%' -c "prompt OFF; lcd $TOKEN_DIR; get encrypted-1p-token; get encrypted-claude-token" > /dev/null 2>&1; then
            if [ -f "$TOKEN_DIR/encrypted-1p-token" ]; then
                # Decrypt the token file with the provided password
                # Using pbkdf2 with 100000 iterations for stronger security
                token=$(openssl enc -aes-256-cbc -pbkdf2 -iter 100000 -d -salt -in "$TOKEN_DIR/encrypted-1p-token" -pass pass:"$decrypt_password" 2>/dev/null)

                # Check if decryption was successful
                if [ $? -ne 0 ]; then
                    echo "Error: Failed to decrypt token. Incorrect password."
                    rm -rf "$TOKEN_DIR"
                    return 1
                fi
            else
                echo "Error: Failed to retrieve encrypted token file"
                rm -rf "$TOKEN_DIR"
                return 1
            fi
            
            # Process Claude token if available
            if [ -f "$TOKEN_DIR/encrypted-claude-token" ]; then
                echo "Decrypting Claude token..."
                
                # Create a temporary file for the Claude token
                CLAUDE_TEMP=$(mktemp)
                
                # Decrypt the Claude token file with the same password
                if ! openssl enc -aes-256-cbc -pbkdf2 -iter 100000 -d -salt -in "$TOKEN_DIR/encrypted-claude-token" -out "$CLAUDE_TEMP" -pass pass:"$decrypt_password" 2>/dev/null; then
                    echo "Error: Failed to decrypt Claude token. Skipping Claude setup."
                else
                    echo "Claude token successfully decrypted."
                    
                    # Get current user
                    current_user=$(whoami)
                    
                    # Set up root's Claude token
                    echo "Setting up Claude token for root..."
                    sudo mkdir -p /root
                    sudo cp "$CLAUDE_TEMP" /root/.claude.json
                    sudo chown root:root /root/.claude.json
                    sudo chmod 600 /root/.claude.json
                    
                    # Set up user's Claude token
                    echo "Setting up Claude token for $current_user..."
                    mkdir -p "/home/$current_user"
                    cp "$CLAUDE_TEMP" "/home/$current_user/.claude.json"
                    chown "$current_user:$current_user" "/home/$current_user/.claude.json"
                    chmod 644 "/home/$current_user/.claude.json"
                    
                    # Clean up temporary file
                    rm -f "$CLAUDE_TEMP"
                    
                    echo "Claude token setup complete."
                fi
            else
                echo "Note: No Claude token found. Skipping Claude setup."
            fi
        else
            echo "Error: Could not connect to syno.home.arpa/deployment using SMB"
            echo "Make sure the server is accessible and the share exists."
            rm -rf "$TOKEN_DIR"
            return 1
        fi

        # Clean up
        rm -rf "$TOKEN_DIR"

        echo "1Password token successfully decrypted."

        # Set the service account token
        export OP_SERVICE_ACCOUNT_TOKEN="$token"

        # Test authentication by listing vaults
        if ! op vault list >/dev/null 2>&1; then
            echo -e "\nAuthentication failed. Verify token validity."
            unset OP_SERVICE_ACCOUNT_TOKEN
            return 1
        fi

        echo -e "\n1Password successfully authenticated!"
    fi

    # Now proceed with the secrets management part
    echo -e "\nConfiguring secrets management..."

    # Check if running as root
    if [ "$(id -u)" -eq 0 ]; then
        echo "Error: This function should be run as a regular user, not root."
        return 1
    fi

    # Get the current username
    local current_user=$(whoami)

    # Create the secrets group if it doesn't exist
    if ! getent group secrets > /dev/null; then
        echo "Creating secrets group..."
        sudo groupadd secrets
    else
        echo "Secrets group already exists."
    fi

    # Check if user is already in the secrets group
    if id -nG "$current_user" | grep -qw "secrets"; then
        echo "$current_user is already a member of the secrets group."
    else
        echo "Adding $current_user to secrets group..."
        sudo usermod -a -G secrets "$current_user"
    fi

    # Ensure /etc/secrets exists with secure permissions
    sudo mkdir -p /etc/secrets
    sudo chown root:secrets /etc/secrets
    sudo chmod 750 /etc/secrets  # Allow directory traversal for secrets group

    # Save token if not already saved
    if [ "$token_loaded_from_file" = false ]; then
        echo -e "\nSaving token to /etc/secrets/.1p..."
        echo "export OP_SERVICE_ACCOUNT_TOKEN='$token'" | sudo tee /etc/secrets/.1p >/dev/null
        sudo chown root:secrets /etc/secrets/.1p
        sudo chmod 640 /etc/secrets/.1p
    fi

    # Fix ownership and permissions for any existing files (including hidden files)
    if [ -d /etc/secrets ] && [ "$(sudo find /etc/secrets -mindepth 1 | wc -l)" -gt 0 ]; then
        echo "Fixing ownership and permissions for existing files..."
        sudo find /etc/secrets -mindepth 1 -maxdepth 1 -exec chown root:secrets {} \;
        sudo find /etc/secrets -mindepth 1 -maxdepth 1 -exec chmod 640 {} \;
    fi

    # Get Debian vault items with explicit --vault flag
    echo -e "\nExporting vault items..."
    items=$(op item list --vault "Debian" --format json | jq -r '.[].id')

    # Export each item to /etc/secrets
    for id in $items; do
        # Get item details with explicit --vault flag
        item_json=$(op item get "$id" --vault "Debian" --format json)

        # Extract title and content
        title=$(jq -r '.title' <<< "$item_json")
        content=$(jq -r '.fields[]?.value // .notes' <<< "$item_json")

        # Write to temporary file first for atomic replacement
        temp_file=$(mktemp)
        echo "$content" > "$temp_file"

        # Move with proper ownership and permissions
        sudo mv "$temp_file" "/etc/secrets/${title}"
        sudo chown root:secrets "/etc/secrets/${title}"
        sudo chmod 640 "/etc/secrets/${title}"
    done

    echo "Vault items exported successfully."

    # Only remind about login if user was just added to the group
    if ! id -nG "$current_user" | grep -qw "secrets"; then
        echo "Note: You may need to log out and back in for group membership to take effect."
        echo "Or run: newgrp secrets"
    fi

    # Ask about keeping token in current shell only if we loaded it fresh
    if [ "$token_loaded_from_file" = false ]; then
        read -rp "Keep OP_SERVICE_ACCOUNT_TOKEN in current shell? [y/N] " keep
        [[ "$keep" != [yY]* ]] && unset OP_SERVICE_ACCOUNT_TOKEN
    fi
}

goto() {
    local file_path=$(fzf --select-1 --exit-0)

    if [ -z "$file_path" ]; then
        echo "No file selected."
        return 1
    fi

    local dir_path=$(dirname "$file_path")

    cd "$dir_path" || return
}

n() {
    if [ -z "$1" ]; then
        nano $(fzf)
    else
        (cd "$1" && nano $(fzf))
    fi
}

port() {
    echo "Checking open files with port $1..."
    echo ""
    sudo lsof -i TCP:$1 -i UDP:$1 | awk 'NR==1 {print} /TCP.*LISTEN|UDP/'
    echo ""

    echo "Searching in /etc/nginx/sites-available/ for port $1..."
    echo ""
    grep -rnH "$1" /etc/nginx/sites-available/ | cut -d: -f1-3
    echo ""

    echo "Checking Docker containers for port $1..."
    echo ""
    docker ps --format "table {{.ID}}\t{{.Image}}\t{{.Ports}}" | grep "$1"
    echo ""
}

pushseed() {
    # Set the target repository and branch
    local repo_url="git@github.com:clearcmos/deb-preseed.git"
    local branch="main"
    
    # Check if git is configured correctly
    local current_remote=$(git config --get remote.origin.url 2>/dev/null)
    
    # If remote is not set or is different
    if [ -z "$current_remote" ] || [ "$current_remote" != "$repo_url" ]; then
        echo "Configuring git remote to push to $repo_url..."
        git remote remove origin 2>/dev/null
        git remote add origin "$repo_url"
        git branch --set-upstream-to=origin/$branch $branch 2>/dev/null
    fi
    
    # Test SSH connection to GitHub
    echo "Testing SSH connection to GitHub..."
    if ! ssh -T git@github.com 2>&1 | grep -q "successfully authenticated"; then
        echo "SSH key not configured properly for GitHub."
        echo "Please add your SSH key to your GitHub account:"
        
        # Check if SSH key exists
        if [ -f ~/.ssh/id_ed25519.pub ]; then
            echo "Here is your public SSH key to add to GitHub:"
            echo "---------- COPY FROM HERE ----------"
            cat ~/.ssh/id_ed25519.pub
            echo "---------- COPY TO HERE ----------"
            echo ""
        else
            echo "1. SSH key not found. Create one: ssh-keygen -t ed25519 -C \"your_email@example.com\""
            echo "2. Start ssh-agent: eval \$(ssh-agent -s)"
            echo "3. Add your key: ssh-add ~/.ssh/id_ed25519"
        fi
        
        echo "Add this key to your GitHub account at: https://github.com/settings/keys"
        echo "Run 'pushseed' again after you've configured the SSH key."
        return 1
    fi
    
    # Proceed with pushing changes
    echo "Pushing changes to $branch branch on $repo_url..."
    git add .
    git commit -m "update"
    git push origin $branch
    
    echo "Done! Changes have been pushed to $branch."
}

pw() {
  default_length=40

  if [[ $1 == "n" ]]; then
    read -p "Enter desired password length: " characters
  else
    read -p "Generating new string... Press Enter for 40 characters / Press n to specify number of characters: " confirm
    if [[ $confirm == "n" ]]; then
      read -p "Enter desired string length: " characters
    else
      characters=$default_length
    fi
  fi

  openssl rand -base64 $characters
}
