1p() {
    # Silent dependency check and installation
    {
        # List of required packages (excluding 1password-cli which is installed separately)
        local required_packages=("curl" "gpg" "cmp" "smbclient" "jq" "openssl" "getent" "sudo")
        local missing_packages=()
        
        # Check which packages are missing
        for pkg in "${required_packages[@]}"; do
            if ! command -v "$pkg" >/dev/null 2>&1; then
                # Special case for cmp which is part of diffutils
                if [ "$pkg" = "cmp" ]; then
                    if ! dpkg -l diffutils >/dev/null 2>&1; then
                        missing_packages+=("diffutils")
                    fi
                else
                    missing_packages+=("$pkg")
                fi
            fi
        done
        
        # Install missing packages if any
        if [ ${#missing_packages[@]} -gt 0 ]; then
            DEBIAN_FRONTEND=noninteractive sudo apt-get update -qq >/dev/null 2>&1
            DEBIAN_FRONTEND=noninteractive sudo apt-get install -qq -y "${missing_packages[@]}" >/dev/null 2>&1
        fi
    } >/dev/null 2>&1
    
    # Start of visible output
    echo "Setting up 1Password CLI..."

    # Better check if actually installed and executable
    if ! which op >/dev/null 2>&1; then
        echo "Installing 1Password CLI..."

        {
            # Use proper temp files with correct permissions
            TEMP_DIR=$(mktemp -d)
            trap 'rm -rf "$TEMP_DIR"' EXIT

            # Download and check if we need to update the keyring
            curl -sS https://downloads.1password.com/linux/keys/1password.asc -o "$TEMP_DIR/1password.asc"

            if [ -f /usr/share/keyrings/1password-archive-keyring.gpg ]; then
                # Compare existing with new
                gpg --dearmor -o "$TEMP_DIR/1password-archive-keyring.gpg" < "$TEMP_DIR/1password.asc" 2>/dev/null
                if cmp -s /usr/share/keyrings/1password-archive-keyring.gpg "$TEMP_DIR/1password-archive-keyring.gpg"; then
                    echo "Keyring is up-to-date."
                else
                    echo "Updating keyring..."
                    sudo cp "$TEMP_DIR/1password-archive-keyring.gpg" /usr/share/keyrings/1password-archive-keyring.gpg
                fi
            else
                # First time installation
                gpg --dearmor < "$TEMP_DIR/1password.asc" | sudo tee /usr/share/keyrings/1password-archive-keyring.gpg >/dev/null
            fi

            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/1password-archive-keyring.gpg] https://downloads.1password.com/linux/debian/$(dpkg --print-architecture) stable main" | \
            sudo tee /etc/apt/sources.list.d/1password.list > /dev/null

            sudo mkdir -p /etc/debsig/policies/AC2D62742012EA22/
            curl -sS https://downloads.1password.com/linux/debian/debsig/1password.pol -o "$TEMP_DIR/1password.pol"
            if [ ! -f /etc/debsig/policies/AC2D62742012EA22/1password.pol ] || ! cmp -s "$TEMP_DIR/1password.pol" /etc/debsig/policies/AC2D62742012EA22/1password.pol; then
                sudo cp "$TEMP_DIR/1password.pol" /etc/debsig/policies/AC2D62742012EA22/1password.pol
            fi

            sudo mkdir -p /usr/share/debsig/keyrings/AC2D62742012EA22
            curl -sS https://downloads.1password.com/linux/keys/1password.asc -o "$TEMP_DIR/1password-debsig.asc"
            if [ -f /usr/share/debsig/keyrings/AC2D62742012EA22/debsig.gpg ]; then
                gpg --dearmor -o "$TEMP_DIR/debsig.gpg" < "$TEMP_DIR/1password-debsig.asc" 2>/dev/null
                if ! cmp -s /usr/share/debsig/keyrings/AC2D62742012EA22/debsig.gpg "$TEMP_DIR/debsig.gpg"; then
                    sudo cp "$TEMP_DIR/debsig.gpg" /usr/share/debsig/keyrings/AC2D62742012EA22/debsig.gpg
                fi
            else
                gpg --dearmor < "$TEMP_DIR/1password-debsig.asc" | sudo tee /usr/share/debsig/keyrings/AC2D62742012EA22/debsig.gpg >/dev/null
            fi

            sudo apt update && sudo apt install -y 1password-cli
        } || {
            echo "Installation failed. Check network connection or permissions."
            return 1
        }
    fi

    # Double check installation worked
    if ! which op >/dev/null 2>&1; then
        echo "Error: 1Password CLI installation failed."
        return 1
    fi

    # Check if we already have a token stored
    local token_loaded_from_file=false
    if [ -f /etc/secrets/.1p ]; then
        source /etc/secrets/.1p
        if [ -n "$OP_SERVICE_ACCOUNT_TOKEN" ]; then
            echo "Using stored 1Password service account token."
            # Test if stored token still works
            if op vault list >/dev/null 2>&1; then
                echo -e "\nSuccessfully authenticated!"
                token_loaded_from_file=true
            else
                echo "Stored token is invalid. Please enter a new one."
            fi
        fi
    fi

    # If token not loaded from file, decrypt it from network share
    if [ "$token_loaded_from_file" = false ]; then
        # Secure credential input
        echo -e "\nDecrypting 1Password token:"

        # Create a temporary directory for the token
        TOKEN_DIR=$(mktemp -d)
        trap 'rm -rf "$TOKEN_DIR" 2>/dev/null || true' EXIT

        # Fetch encrypted token - do this outside the password loop
        echo "Fetching encrypted token from 192.168.1.4..."

        # smbclient should already be installed by our pre-check
        if ! which smbclient >/dev/null 2>&1; then
            echo "Error: smbclient not available. Cannot fetch token."
            rm -rf "$TOKEN_DIR"
            return 1
        fi

        # Use smbclient to fetch the encrypted token
        if ! smbclient //192.168.1.4/deployment -U 'guest%' -c "prompt OFF; lcd $TOKEN_DIR; get encrypted-1p-token" > /dev/null 2>&1; then
            echo "Error: Could not connect to 192.168.1.4/deployment using SMB"
            echo "Make sure the server is accessible and the share exists."
            rm -rf "$TOKEN_DIR"
            return 1
        fi

        if [ ! -f "$TOKEN_DIR/encrypted-1p-token" ]; then
            echo "Error: Failed to retrieve encrypted token file"
            rm -rf "$TOKEN_DIR"
            return 1
        fi

        # Try decryption until successful
        while true; do
            # Get password from user to decrypt token
            read -rsp "Enter password to decrypt token: " decrypt_password
            echo  # New line after password input
            
            # Check for empty password
            if [ -z "$decrypt_password" ]; then
                echo -e "\nError: Password cannot be empty"
                continue
            fi
            
            # Attempt to decrypt
            token=$(openssl enc -aes-256-cbc -pbkdf2 -iter 100000 -d -salt -in "$TOKEN_DIR/encrypted-1p-token" -pass pass:"$decrypt_password" 2>/dev/null)
            
            # Check if decryption was successful
            if [ $? -eq 0 ]; then
                echo "1Password token successfully decrypted."
                break
            else
                echo "Error: Failed to decrypt token. Incorrect password. Please try again."
            fi
        done

        # Clean up
        rm -rf "$TOKEN_DIR"

        # Set the service account token
        export OP_SERVICE_ACCOUNT_TOKEN="$token"

        # Test authentication by listing vaults
        if ! op vault list >/dev/null 2>&1; then
            echo -e "\nAuthentication failed. Verify token validity."
            unset OP_SERVICE_ACCOUNT_TOKEN
            return 1
        fi

        echo -e "\n1Password successfully authenticated!"
    fi

    # Now proceed with the secrets management part
    echo -e "\nConfiguring secrets management..."

    # Check if running as root
    if [ "$(id -u)" -eq 0 ]; then
        echo "Error: This function should be run as a regular user, not root."
        return 1
    fi

    # Get the current username
    local current_user=$(whoami)

    # Create the secrets group if it doesn't exist
    if ! getent group secrets > /dev/null; then
        echo "Creating secrets group..."
        sudo groupadd secrets
    else
        echo "Secrets group already exists."
    fi

    # Check if user is already in the secrets group
    if id -nG "$current_user" | grep -qw "secrets"; then
        echo "$current_user is already a member of the secrets group."
    else
        echo "Adding $current_user to secrets group..."
        sudo usermod -a -G secrets "$current_user"
    fi

    # Ensure /etc/secrets exists with secure permissions
    sudo mkdir -p /etc/secrets
    sudo chown root:secrets /etc/secrets
    sudo chmod 750 /etc/secrets  # Allow directory traversal for secrets group

    # Save token if not already saved
    if [ "$token_loaded_from_file" = false ]; then
        echo -e "\nSaving token to /etc/secrets/.1p..."
        echo "export OP_SERVICE_ACCOUNT_TOKEN='$token'" | sudo tee /etc/secrets/.1p >/dev/null
        sudo chown root:secrets /etc/secrets/.1p
        sudo chmod 640 /etc/secrets/.1p
    fi

    # Fix ownership and permissions for any existing files (including hidden files)
    if [ -d /etc/secrets ] && [ "$(sudo find /etc/secrets -mindepth 1 | wc -l)" -gt 0 ]; then
        echo "Fixing ownership and permissions for existing files..."
        sudo find /etc/secrets -mindepth 1 -maxdepth 1 -exec chown root:secrets {} \;
        sudo find /etc/secrets -mindepth 1 -maxdepth 1 -exec chmod 640 {} \;
    fi

    # Get Debian vault items with explicit --vault flag
    echo -e "\nExporting vault items..."
    items=$(op item list --vault "Debian" --format json | jq -r '.[].id')

    # Export each item to /etc/secrets
    for id in $items; do
        # Get item details with explicit --vault flag
        item_json=$(op item get "$id" --vault "Debian" --format json)

        # Extract title and content
        title=$(jq -r '.title' <<< "$item_json")
        
        # Skip .claude.json item
        if [ "$title" = ".claude.json" ]; then
            echo "Skipping .claude.json - will be handled separately"
            continue
        fi
        
        content=$(jq -r '.fields[]?.value // .notes' <<< "$item_json")

        # Write to temporary file first for atomic replacement
        temp_file=$(mktemp)
        echo "$content" > "$temp_file"

        # Move with proper ownership and permissions
        sudo mv "$temp_file" "/etc/secrets/${title}"
        sudo chown root:secrets "/etc/secrets/${title}"
        sudo chmod 640 "/etc/secrets/${title}"
    done

    # Setup Claude token from 1Password
    echo -e "\nSetting up Claude token from 1Password..."
    setup_claude_token

    echo "Vault items exported successfully."

    # Only remind about login if user was just added to the group
    if ! id -nG "$current_user" | grep -qw "secrets"; then
        echo "Note: You may need to log out and back in for group membership to take effect."
        echo "Or run: newgrp secrets"
    fi

    # Ask about keeping token in current shell only if we loaded it fresh
    if [ "$token_loaded_from_file" = false ]; then
        read -rp "Keep OP_SERVICE_ACCOUNT_TOKEN in current shell? [y/N] " keep
        [[ "$keep" != [yY]* ]] && unset OP_SERVICE_ACCOUNT_TOKEN
    fi
}

# Function to retrieve and set up Claude token from 1Password
setup_claude_token() {
    echo "Retrieving Claude token from 1Password..."

    # Check if authenticated to 1Password
    if ! op vault list >/dev/null 2>&1; then
        echo "Error: Not authenticated to 1Password. Cannot retrieve Claude token."
        return 1
    fi

    # Get current user
    local current_user=$(whoami)
    
    # Check if existing claude.json files have more than 20 lines
    local root_file_exists=false
    local user_file_exists=false
    
    # Check root's claude.json - use sudo to check if it exists and has sufficient lines
    if sudo test -f "/root/.claude.json"; then
        # Using sudo with a shell command to handle file redirection properly
        local root_lines=$(sudo bash -c "wc -l < /root/.claude.json" 2>/dev/null || echo 0)
        if [ "$root_lines" -gt 20 ]; then
            echo "Existing Claude token for root has more than 20 lines - skipping update"
            root_file_exists=true
        fi
    fi
    
    # Check user's claude.json
    if [ -f "/home/$current_user/.claude.json" ]; then
        local user_lines=$(wc -l < "/home/$current_user/.claude.json" 2>/dev/null || echo 0)
        if [ "$user_lines" -gt 20 ]; then
            echo "Existing Claude token for $current_user has more than 20 lines - skipping update"
            user_file_exists=true
        fi
    fi
    
    # If both files exist with sufficient content, we can exit early
    if [ "$root_file_exists" = true ] && [ "$user_file_exists" = true ]; then
        echo "Existing Claude tokens found for both root and user - no updates needed"
        return 0
    fi

    # Create a temporary file for the Claude token
    CLAUDE_TEMP=$(mktemp)

    # Try to get the Claude token document from 1Password
    # First, check if the item exists in any vault
    claude_item_info=$(op item list --format=json | jq -r '.[] | select(.title == ".claude.json")' 2>/dev/null)

    if [ -z "$claude_item_info" ]; then
        echo "Error: Claude token item not found in any vault."
        rm -f "$CLAUDE_TEMP"
        return 1
    fi

    # Extract the vault and item ID
    item_id=$(echo "$claude_item_info" | jq -r '.id')
    vault_id=$(echo "$claude_item_info" | jq -r '.vault.id')

    echo "Found Claude token item (ID: $item_id) in vault ID: $vault_id"

    # Get more details about the item to find the document reference
    item_details=$(op item get "$item_id" --vault="$vault_id" --format=json)

    # Check if there are any files attached
    if ! echo "$item_details" | jq -e '.files' >/dev/null 2>&1; then
        echo "Error: No files found attached to the Claude token item."
        rm -f "$CLAUDE_TEMP"
        return 1
    fi

    # Get the ID of the attached file
    file_id=$(echo "$item_details" | jq -r '.files[0].id')

    if [ -z "$file_id" ] || [ "$file_id" == "null" ]; then
        echo "Error: Could not find file ID in the Claude token item."
        rm -f "$CLAUDE_TEMP"
        return 1
    fi

    echo "Found document with ID: $file_id in item: $item_id"

    # Get the document using the item ID (not the file ID) with force flag to prevent prompts
    if ! op document get "$item_id" --vault="$vault_id" --out-file="$CLAUDE_TEMP" --force 2>/dev/null; then
        echo "Error: Failed to retrieve Claude token document from 1Password."
        rm -f "$CLAUDE_TEMP"
        return 1
    fi

    echo "Claude token successfully retrieved from 1Password."

    # Set up root's Claude token if needed
    if [ "$root_file_exists" = false ]; then
        echo "Setting up Claude token for root..."
        sudo mkdir -p /root
        sudo cp "$CLAUDE_TEMP" /root/.claude.json
        sudo chown root:root /root/.claude.json
        sudo chmod 600 /root/.claude.json
    fi

    # Set up user's Claude token if needed
    if [ "$user_file_exists" = false ]; then
        echo "Setting up Claude token for $current_user..."
        mkdir -p "/home/$current_user"
        cp "$CLAUDE_TEMP" "/home/$current_user/.claude.json"
        chown "$current_user:$current_user" "/home/$current_user/.claude.json"
        chmod 644 "/home/$current_user/.claude.json"
    fi

    # Clean up temporary file
    rm -f "$CLAUDE_TEMP"

    echo "Claude token setup complete."
}

goto() {
    local file_path=$(fzf --select-1 --exit-0)

    if [ -z "$file_path" ]; then
        echo "No file selected."
        return 1
    fi

    local dir_path=$(dirname "$file_path")

    cd "$dir_path" || return
}

n() {
    if [ -z "$1" ]; then
        nano $(fzf)
    else
        (cd "$1" && nano $(fzf))
    fi
}

port() {
    echo "Checking open files with port $1..."
    echo ""
    sudo lsof -i TCP:$1 -i UDP:$1 | awk 'NR==1 {print} /TCP.*LISTEN|UDP/'
    echo ""

    echo "Searching in /etc/nginx/sites-available/ for port $1..."
    echo ""
    grep -rnH "$1" /etc/nginx/sites-available/ | cut -d: -f1-3
    echo ""

    echo "Checking Docker containers for port $1..."
    echo ""
    docker ps --format "table {{.ID}}\t{{.Image}}\t{{.Ports}}" | grep "$1"
    echo ""
}

pushseed() {
  # Silent dependency check and installation
  {
    # List of required packages
    local required_packages=("git" "grep" "sudo")
    local missing_packages=()
    
    # Check which packages are missing
    for pkg in "${required_packages[@]}"; do
      if ! command -v "$pkg" >/dev/null 2>&1; then
        missing_packages+=("$pkg")
      fi
    done
    
    # Install missing packages if any
    if [ ${#missing_packages[@]} -gt 0 ]; then
      DEBIAN_FRONTEND=noninteractive sudo apt-get update -qq >/dev/null 2>&1
      DEBIAN_FRONTEND=noninteractive sudo apt-get install -qq -y "${missing_packages[@]}" >/dev/null 2>&1
    fi
  } >/dev/null 2>&1

  # Get the current username
  local current_user=$(whoami)
  
  # Run the sensitive pattern scanner first
  local pattern_scanner="/home/${current_user}/deb-preseed/utils/scan-sensitive-patterns.sh"
  
  echo "Running sensitive pattern scan before proceeding..."
  local scan_result=$(bash "$pattern_scanner")
  
  # Check if the result exactly matches the expected output
  if [ "$scan_result" != "No matches found for any patterns." ]; then
    echo "ERROR: Sensitive patterns were found in the codebase."
    echo "Please check the scan results and remove any sensitive information before pushing:"
    echo "$scan_result"
    return 1
  fi
  
  echo "No sensitive patterns found. Proceeding with push..."
  
  # Set the target repository and branch
  local repo_name="clearcmos/deb-preseed"
  local branch="main"
  local token_file="/etc/secrets/.github"
  
  # Check if token file exists
  if [ ! -f "$token_file" ]; then
    echo "GitHub token file not found at $token_file"
    return 1
  fi
  
  # Source the file to get the exported variable
  source "$token_file"
  if [ -z "$GITHUB_TOKEN" ]; then
    echo "GITHUB_TOKEN variable not found or empty in $token_file"
    return 1
  fi
  
  # Set remote URL without embedding token
  local repo_url="https://github.com/${repo_name}.git"
  
  # Configure git if needed
  local current_remote=$(git config --get remote.origin.url 2>/dev/null)
  if [ -z "$current_remote" ] || ! echo "$current_remote" | grep -q "$repo_name"; then
    echo "Configuring git remote..."
    git remote remove origin 2>/dev/null
    git remote add origin "$repo_url"
    git branch --set-upstream-to=origin/$branch $branch 2>/dev/null
  fi
  
  # Proceed with pushing changes
  echo "Pushing changes to $branch branch..."
  
  # Set git identity if not already configured
  if ! git config user.email >/dev/null 2>&1; then
    git config --local user.email "whatever@domain.com"
  fi
  if ! git config user.name >/dev/null 2>&1; then
    git config --local user.name "clearcmos"
  fi
  
  git add .
  git commit -m "update"
  
  # Setup credential helper to use the token
  git config --local credential.helper store
  
  # Store GitHub credentials temporarily for this push
  echo "https://oauth2:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
  chmod 600 ~/.git-credentials
  
  # Push changes
  git push origin $branch
  
  # Remove credentials file after use
  rm -f ~/.git-credentials
  
  # Unset credential helper
  git config --local --unset credential.helper
  
  echo "Done! Changes have been pushed to $branch."
}

pw() {
  default_length=40

  if [[ $1 == "n" ]]; then
    read -p "Enter desired password length: " characters
  else
    read -p "Generating new string... Press Enter for 40 characters / Press n to specify number of characters: " confirm
    if [[ $confirm == "n" ]]; then
      read -p "Enter desired string length: " characters
    else
      characters=$default_length
    fi
  fi

  openssl rand -base64 $characters
}

secrets() {
  # Silent dependency check and installation
  {
    # List of required packages
    local required_packages=("jq" "stat" "sudo" "date")
    local missing_packages=()
    
    # Check which packages are missing
    for pkg in "${required_packages[@]}"; do
      if ! command -v "$pkg" >/dev/null 2>&1; then
        # Special case for stat which is part of coreutils
        if [ "$pkg" = "stat" ] || [ "$pkg" = "date" ]; then
          if ! dpkg -l coreutils >/dev/null 2>&1; then
            missing_packages+=("coreutils")
          fi
        else
          missing_packages+=("$pkg")
        fi
      fi
    done
    
    # Install missing packages if any
    if [ ${#missing_packages[@]} -gt 0 ]; then
      DEBIAN_FRONTEND=noninteractive sudo apt-get update -qq >/dev/null 2>&1
      DEBIAN_FRONTEND=noninteractive sudo apt-get install -qq -y "${missing_packages[@]}" >/dev/null 2>&1
    fi
  } >/dev/null 2>&1
  
  echo "Syncing secrets between 1Password Debian vault and /etc/secrets..."
  
  # Check if we already have a token stored
  local token_loaded_from_file=false
  if [ -f /etc/secrets/.1p ]; then
    source /etc/secrets/.1p
    if [ -n "$OP_SERVICE_ACCOUNT_TOKEN" ]; then
      echo "Using stored 1Password service account token."
      # Test if stored token still works
      if op vault list >/dev/null 2>&1; then
        echo "Successfully authenticated!"
        token_loaded_from_file=true
      else
        echo "Stored token is invalid. Run the 1p function to authenticate."
        return 1
      fi
    fi
  fi
  
  if [ "$token_loaded_from_file" = false ]; then
    echo "No valid 1Password token found. Run the 1p function first to authenticate."
    return 1
  fi
  
  # Ensure /etc/secrets exists
  if ! sudo test -d /etc/secrets; then
    echo "Error: /etc/secrets directory does not exist"
    return 1
  fi
  
  # Check if we're in the secrets group
  if ! id -nG | grep -qw "secrets"; then
    echo "Warning: You're not in the secrets group. Some operations may require sudo."
  fi
  
  # Create a temporary directory for syncing
  TEMP_DIR=$(mktemp -d)
  trap 'rm -rf "$TEMP_DIR" 2>/dev/null || true' EXIT
  
  echo "Fetching items from 1Password Debian vault..."
  # Get Debian vault items
  items=$(op item list --vault "Debian" --format json)
  if [ $? -ne 0 ]; then
    echo "Error: Failed to list items from 1Password Debian vault"
    rm -rf "$TEMP_DIR"
    return 1
  fi
  
  # Get the IDs only
  item_ids=$(echo "$items" | jq -r '.[].id')
  
  # Counter for changes
  local updated_op_to_local=0
  local updated_local_to_op=0
  local identical=0
  
  # Process each item
  for id in $item_ids; do
    # Get item details
    item_json=$(op item get "$id" --vault "Debian" --format json)
    
    # Extract title and modification time
    title=$(echo "$item_json" | jq -r '.title')
    
    # Skip .claude.json item
    if [ "$title" = ".claude.json" ]; then
      echo "Skipping .claude.json item"
      continue
    fi
    
    # Get last modified time in seconds since epoch
    # Use updated_at field which records when the item was last modified
    op_modified=$(echo "$item_json" | jq -r '.updated_at' | date -d "$(cat)" +%s 2>/dev/null)
    if [ $? -ne 0 ]; then
      echo "Warning: Could not parse modification time for item: $title, assuming current time"
      op_modified=$(date +%s)
    fi
    
    # Extract content
    content=$(echo "$item_json" | jq -r '.fields[]?.value // .notes')
    
    # Check if local file exists
    local_file="/etc/secrets/${title}"
    if sudo test -f "$local_file"; then
      # Get local file modification time using sudo
      local_modified=$(sudo stat -c %Y "$local_file" 2>/dev/null)
      if [ $? -ne 0 ]; then
        echo "Warning: Could not get modification time for $local_file, assuming older than vault item"
        local_modified=0
      fi
      
      # Create temp file for comparison
      temp_op_file="$TEMP_DIR/op_${title}"
      echo "$content" > "$temp_op_file"
      
      # Compare file contents (using sudo to read local file)
      if sudo cmp -s "$temp_op_file" "$local_file"; then
        echo "File $title is identical in vault and locally"
        identical=$((identical+1))
      else
        # Content differs, compare modification times to determine which is newer
        if [ "$op_modified" -gt "$local_modified" ]; then
          echo "1Password version of $title is newer - updating local file"
          # Write to temporary file first for atomic replacement
          sudo cp "$temp_op_file" "$local_file"
          sudo chown root:secrets "$local_file"
          sudo chmod 640 "$local_file"
          updated_op_to_local=$((updated_op_to_local+1))
        else
          echo "Local version of $title is newer - updating 1Password"
          # Update the vault item
          local local_content=$(sudo cat "$local_file")
          
          # Update the item in 1Password using direct field assignment syntax
          if op item edit "$id" --vault "Debian" "notesPlain=$local_content" > /dev/null; then
            echo "Successfully updated $title in 1Password"
            updated_local_to_op=$((updated_local_to_op+1))
          else
            echo "Error: Failed to update $title in 1Password"
          fi
        fi
      fi
    else
      # Local file doesn't exist, create it from 1Password
      echo "File $title exists in vault but not locally - creating local file"
      temp_file="$TEMP_DIR/${title}"
      echo "$content" > "$temp_file"
      
      # Move with proper ownership and permissions
      sudo mv "$temp_file" "$local_file"
      sudo chown root:secrets "$local_file"
      sudo chmod 640 "$local_file"
      updated_op_to_local=$((updated_op_to_local+1))
    fi
  done
  
  # Check for local files that don't exist in 1Password
  echo "Checking for local files not in 1Password..."
  # Get list of all secret titles from 1Password
  op_titles=$(echo "$items" | jq -r '.[].title')
  
  # List all files in /etc/secrets
  local_files=$(sudo find /etc/secrets -maxdepth 1 -type f -exec basename {} \; | grep -v "^\.claude\.json$")
  
  for file in $local_files; do
    # Check if file exists in 1Password titles
    if ! echo "$op_titles" | grep -q "^$file$"; then
      echo "File $file exists locally but not in vault - creating in 1Password"
      
      # Read file content
      local content=$(sudo cat "/etc/secrets/$file")
      
      # Create the item in 1Password using correct field assignment syntax
      if op item create --vault "Debian" --category="Secure Note" --title="$file" "notesPlain=$content" > /dev/null; then
        echo "Successfully created $file in 1Password"
        updated_local_to_op=$((updated_local_to_op+1))
      else
        echo "Error: Failed to create $file in 1Password"
      fi
    fi
  done
  
  # Clean up
  rm -rf "$TEMP_DIR"
  
  # Summary
  echo -e "\nSync complete!"
  echo "Files identical: $identical"
  echo "Updated from 1Password to local: $updated_op_to_local"
  echo "Updated from local to 1Password: $updated_local_to_op"
  
  return 0
}
